/*
 * Copyright (c) [2020] SUSE LLC
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact SUSE LLC.
 *
 * To contact SUSE LLC about this file by physical or electronic mail, you may
 * find current contact information at www.suse.com.
 */

import cockpit from 'cockpit';

/**
 * Converts a HTML element to a plain object
 *
 * @function
 *
 * @param {HTMLElement} element - Element to convert to JSON
 * @param {Array<string>} listElement - Special elements to be considered lists
 * @return {Object} Plain object representing the element (and its children)
 *
 * @ignore
 */
const elementToJson = (element, listElements) => {
    const children = Array.from(element.children);
    const key = element.localName.replace(/-/g, '_');

    if (children.length === 0) {
        return { [key]: element.textContent };
    } else {
        let value = children.map(e => elementToJson(e, listElements));

        if (listElements.includes(key)) {
            value = value.map(v => Object.values(v)[0]);
        } else {
            value = value.reduce((all, child) => ({ ...all, ...child }), {});
        }

        const attrs = elementAttributes(element);
        if (Object.keys(attrs).length > 0) value = { ...value, _attrs: attrs };

        return { [key]: value };
    }
};

const elementAttributes = (element) => {
    return Array.from(element.attributes).reduce((all, attr) => (
        { ...all, [attr.nodeName]: attr.nodeValue }
    ), {});
};

/* @ignore */
const emptyTagsRegExp = new RegExp(/<\w+\/>/, 'g');

/**
 * Sanitize the XML string before it gets processed
 *
 * Removes empty tags, as they will cause troubles when parsing.
 *
 * @param {string} xmlString - XML string to sanitize
 */
const sanitizeXml = (xmlString) => {
    return xmlString.replace(emptyTagsRegExp, '');
};

/**
 * Returns a plain object representing the given string
 *
 * @todo Unfortunately, the XML generated by Wicked is not valid. So the string
 * is parsed as HTML and some additional tweak is needed (@see sanitizeXml).
 *
 * @param {string} xmlString - XML string to convert to JSON
 * @param {Array<string>} listElements - Special elements to be considered lists
 * @return {Object} Plain object representing the given XML
 *
 * @ignore
 */
const XmlToJson = (xmlString, listElements = []) => {
    const parser = new DOMParser();
    const dom = parser.parseFromString(sanitizeXml(xmlString), 'text/html');
    const [body] = dom.getElementsByTagName('body');
    const result = elementToJson(body, listElements);
    return result.body;
};

/**
 * Class to interact with Wicked.
 *
 * @class
 *
 * This class is responsible for communicating with Wicked:
 *
 * - It uses the CLI to get interfaces and configurations information.
 * - It listens to D-Bus signals and runs the given callbacks.
 */
class WickedClient {
    constructor() {
        this._callbacks = [];
        this._interfaces = undefined;
        this._connections = undefined;
        this._onInterfaceChange = [];

        this.networkClient = cockpit.dbus('org.opensuse.Network', {
            bus: 'system', superuser: 'require'
        });

        this._onSignal('deviceDelete', this._onDeviceDelete.bind(this));
        this._onSignal(['deviceCreate', 'networkUp', 'linkUp', 'networkDown', 'linkDown', 'addressAcquired',
                        'deviceReady', 'deviceChange'], this._onDeviceEvent.bind(this));

        this.start();
    }

    /**
     * Callback for interface changes
     *
     * @callback wickedInterfaceChangeCallback
     * @param {string} signal - The signal which caused the change.
     * @param {object} iface - Wicked representation of the affected interface.
     */

    /**
     * Registers a callback to be called when an interface changes
     *
     * @param {wickedInterfaceChangeCallback} fn - Callback to be called when an interface changes
     */
    onInterfaceChange(fn) {
        this._onInterfaceChange.push(fn);
    }

    start() {
        // TODO: de-bouncing.
        this.networkClient.subscribe(
            { interface: 'org.opensuse.Network.Interface' },
            this._runSignalCallbacks.bind(this)
        );
    }

    /**
     * Returns a promise that resolves to an array of objects representing interfaces
     *
     * @param {object} options - Query options
     * @param {boolean} options.cache - Use cached data if available
     * @return {Promise.<Array.<Object>>} Promise that resolves to a list of interfaces
     */
    async getInterfaces({ cache = false } = {}) {
        if (this._interfaces && cache) return this._interfaces;

        const stdout = await cockpit.spawn(['/usr/sbin/wicked', 'show-xml']);
        this._interfaces = XmlToJson(stdout, ['body']);
        return this._interfaces;
    }

    /**
     * Returns a promise that resolves to an array of objects representing configurations
     *
     * @param {object} options - Query options
     * @param {boolean} options.cache - Use cached data if available
     * @return {Promise.<Array.<Object>>} Promise that resolves to a list of interfaces
     */
    async getConfigurations({ cache = false } = {}) {
        if (this._connections && cache) return this._connections;

        const stdout = await cockpit.spawn(['/usr/sbin/wicked', 'show-config']);
        this._connections = XmlToJson(stdout, ['body', 'slaves', 'ipv4:static', 'ipv6:static', 'ports']);
        return this._connections;
    }

    async getInterfaceByName(name) {
        const stdout = await cockpit.spawn(['/usr/sbin/wicked', 'show-xml', name]);
        const [data] = XmlToJson(stdout, ['body']);
        return data;
    }

    /**
     * Returns the interface under an given D-Bus path
     *
     * @param {string} path - D-Bus path
     * @param {object} options - Query options
     * @param {boolean} options.cache - Use cached data if available
     * @return {Promise.<Object|undefined>}
     */
    getInterfaceByPath(path, opts = {}) {
        return new Promise((resolve, reject) => {
            this.getInterfaces(opts).then(data => {
                const iface = data.find(i => i._attrs.path === path);
                resolve(iface);
            });
        });
    }

    /**
     * Reloads a connection
     *
     * TODO: better error handling
     *
     * @return {Promise} Result of the operation
     */
    reloadConnection(name) {
        return cockpit.spawn(['/usr/sbin/wicked', 'ifreload', name], { superuser: "require" });
    }

    /**
     * Register a callback for a set of signals
     *
     * @ignore
     *
     * @param {Array<string>} signals - List of signals (e.g., ['deviceCreate', 'deviceDelete'])
     * @param {Function} fn - Function to call. It receives the signal and the affected interface.
     */
    _onSignal(signals, fn) {
        this._callbacks.push({
            fn,
            signals: (typeof signals === "string") ? [signals] : signals
        });
    }

    /**
     * Run internal callbacks defined using the '_onSignal' method
     *
     * @ignore
     */
    async _runSignalCallbacks(path, dbusIface, signal, args) {
        const callbacks = this._callbacks.filter(c => c.signals.includes(signal)).map(c => c.fn);
        if (callbacks.length === 0) return;

        callbacks.forEach(fn => fn(signal, path));
    }

    /**
     * Handler of the 'deviceDelete' D-Bus signal
     *
     * It requires special handling because the interface will disappear.
     *
     * @ignore
     *
     * @param {string} signal - D-Bus signal
     * @param {string} path - Device D-Bus path
     */
    async _onDeviceDelete(signal, path) {
        const iface = await this.getInterfaceByPath(path, { cache: true });
        if (!iface) return;

        this._interfaces = this._interfaces.filter(i => i.interface.name !== iface.interface.name);
        const { ethtool } = iface;
        const updatedIface = { ...iface, ethtool: { ...ethtool, link: false } };
        this._onInterfaceChange.forEach(fn => fn(signal, updatedIface));
    }

    /**
     * Generic handler for several device events
     *
     * This handler invokes the callbacks that were set using the 'onDeviceChange' method.
     *
     * @ignore
     *
     * @param {string} signal - D-Bus signal
     * @param {string} path - Device D-Bus path
     */
    async _onDeviceEvent(signal, path) {
        // FIXME: it re-reads the list of devices. We could use the cache
        // and force the reloading of just the changed device.
        const iface = await this.getInterfaceByPath(path, { cache: false });
        if (!iface) return;

        this._onInterfaceChange.forEach(fn => fn(signal, iface));
    }
}

export default WickedClient;
